- 前言

- 第一章：Go与操作系统

  - 1.1 本书结构

  - 1.2 Go的历史

  - 1.3 Why Go?

  - 1.4 Go的优势

    - 1.4.1 Go完美吗？
      - 1.4.1.1 什么是进程

    - 1.5 好用的Godoc

  - 1.6 Go的编译

  - 1.7 Go的可执行程序

  - 1.8 两条Go的基本准则

    - 1.8.1 无用的包不要导入
    - 1.8.2 "{}"的唯一位置

  - 1.9 下载你想用的包

  - 1.10 Unix的标准输入，标准输出，标准错误

  - 1.11 关于Go的打印输出

  - 1.12 使用标准输出

  - 1.13 得到用户输入

  - 1.14 关于 := 和 = 

    - 1.14.1 从标准输入读取
    - 1.14.2 处理命令行参数

  - 1.15 关于错误的输出

  - 1.16 写入日志文件

    - 1.16.1 logging的级别
    - 1.16.2 Unix log 设备文件
    - 1.16.3 Log 进程
    - 1.16.4 处理日志信息的示例程序
    - 关于 log.Fatal()
    - 关于 log.Panic()

  - Go的错误处理机制

    - error 的数据类型
    - 错误处理

  - 延展阅读

  - 练习

  - 本章小结

- 第二章 深入剖析Go的内部原理

  - 2.1 Go编译器
  - 2.2 Go的垃圾回收机制
    - 2.2.1 垃圾回收算法：Tricolor
    - 2.2.2 Go 垃圾回收器
    - 2.2.3 不安全的代码
    - 2.2.4 一些不安全的Go package
    - 2.2.5 不安全Go package 的一些代码示例
  - 2.3 Go调用C代码
    - 2.3.1 使用Go在同一文件中调用C代码
    - 2.3.2 使用Go跨文件调用C代码
    - 2.3.3 CGo的代码示例
  - 2.4 C调用Go代码
    - 2.4.1 Go package
    - 2.4.2 C代码
  - 2.5 关于 Panic和Recover
  - 2.6 C调用Go代码
    - 2.6.1 CGo的代码示例
  - 2.7 defer 关键字
  - 2.8 单独使用Panic函数
  - 2.9 两个实用的UNIX小工具
    - 2.9.1 strace
    - 2.9.2 dtrace
  - 2.10 了解Go environment的函数
  - 2.11 Go与汇编
  - 2.12 Go的节点树
  - 2.13 了解更多构建信息
  - 2.14 关于Go代码的几点建议
  - 2.15 延展阅读
  - 2.16 练习
  - 2.17 本章小结

- 第三章 Go基本数据类型

  - 3.1 Go for循环
    - 3.1.1 for 循环
    - 3.1.2 while 循环
    - 3.1.3 关键字 range
    - 3.1.4 Go for 循环示例
  - 3.2 Go 数组
    - 3.2.1 多维数组
    - 3.2.2 Go数组的缺陷
  - 3.3 Go 切片
    - 3.3.1 切片基本操作
    - 3.3.2 切片的自动扩容
    - 3.3.3 字节切片
    - 3.3.4 copy() 函数解析
    - 3.3.5 多维切片
    - 3.3.6 使用切片的代码示例
    - 3.3.7 使用sort.slice()排序
  - 3.4 Go Map
    - 3.4.1 Map值为nil的坑
    - 3.4.2 何时该使用Map?
  - 3.5 Go 常量
    - 3.5.1 常量生成器：iota
  - 3.6 Go 指针
  - 3.7 时间与日期的处理技巧
    - 3.7.1 解析时间
    - 3.7.2 解析时间的代码示例
    - 3.7.3 解析日期
    - 3.7.4 解析日期的代码示例
    - 3.7.5 格式化时间与日期
  - 3.8 延展阅读
  - 3.9 练习
  - 3.10 本章小结

- 第四章 组合类型的使用

  - 4.1 关于组合类型
  - 4.2 结构体
    - 4.2.1 结构体指针
    - 4.2.2 new 关键字
  - 4.3 元组
  - 4.4 正则表达式与模式匹配
    - 4.4.1 理论知识
    - 4.4.2 简单的正则表达式示例
    - 4.4.3 高级的正则表达式示例
    - 4.4.4 正则匹配IPv4地址
  - 4.5 字符串
    - 4.5.1 rune是什么？
    - 4.5.2 关于Unicode的包
    - 4.5.3 关于字符串处理的包
  - 4.6 switch语句
  - 4.7 计算Pi的精确值
  - 4.8 实现简单的K-V存储
  - 4.9 延展阅读
  - 4.10 练习
  - 4.11 本章小结

- 第五章 数据结构的Go描述

  - 5.1 图及其节点

  - 5.2 算法复杂度简介

  - 5.3 二叉树

    - 5.3.1 Go实现二叉树
    - 5.3.2 二叉树的优势

  - 5.4 哈希表

    5.4.1 Go实现哈希表

    5.4.2 lookup函数实现

    5.4.3 哈希表的优势

  - 5.5 链表

    5.5.1 Go 实现链表

    5.5.2 链表的优势

  - 5.6 双向链表

    - 5.6.1 Go实现双向链表
    - 5.6.2 双向链表的优势

  - 5.7 队列

    - 5.7.1 Go实现队列

  - 5.8 栈

    - 5.8.1 Go实现栈

  - 5.9 Go标准库 container

    - 5.9.1 container/heap的使用
    - 5.9.2 container/list的使用
    - 5.9.3 container/ring的使用

  - 5.10 随机数

    - 5.10.1 随机字符串
  - 5.11 延展阅读
  - 5.12 练习
  - 5.13 本章小结

- 第六章 Go package中不为人知的知识

  - 6.1 关于Go packages
  - 6.2 Go函数
    - 6.2.1 匿名函数
    - 6.2.2 多返回值的函数
    - 6.2.3 可命名的函数返回值
    - 6.2.4 参数为指针的函数
    - 6.2.5 返回值为指针的函数
    - 6.2.6 闭包
    - 6.2.7 函数作为参数
  - 6.3 设计你的Go packages
    - 6.3.1 编译一个Go package
    - 6.3.2 私有变量和函数
    - 6.3.3 init() 函数
  - 6.4 阅读标准库代码
    - 6.4.1 探索net/url代码包
    - 6.4.2 探索log/syslog代码
  - 6.5 关于创建优雅的Go package的建议
  - 6.6 系统调用的包
    - 6.6.1 fmt.Println()的工作原理
  - 6.7 Text和HTML的模板
    - 6.7.1 生成text输出
    - 6.7.2 生成HTML输出
    - 6.7.3 基本SQLite3命令
  - 6.8 延展阅读
  - 6.9 练习
  - 6.10 本章小结

- 第七章 反射和接口

  - 7.1 类型方法
  - 7.2 Go的接口
  - 7.3 类型断言
  - 7.4 设计接口
    - 7.4.1  接口的使用
    - 7.4.2 switch用于类型判断
  - 7.5 反射
    - 7.5.1 使用反射的简单示例
    - 7.5.2 反射进阶
    - 7.5.3 反射的三个缺点
  - 7.6 Go的OOP思想
  - 7.7 延展阅读
  - 7.8 练习
  - 7.9 本章小结

- 第八章 Go UNIX系统编程

  - 8.1 关于UNIX进程
  - 8.2 flag包
  - 8.3 io.Reader 和 io.Writer接口
    - 8.3.1 文件输入、输出的缓冲和非缓冲方式
  - 8.4 bufio包
  - 8.5 读取text文件
    - 8.5.1 逐行读取text文件
    - 8.5.2 按单词读取text文件
    - 8.5.3 按字符读取text文件
    - 8.5.4 从/dev/random中读取
  - 8.6 读取指定字节数量的数据
  - 8.7 为什么使用二进制形式读取
  - 8.8 读取CSV文件
  - 8.9 写入文件
  - 8.10 将数据保存到磁盘
  - 8.11 重温strings包
  - 8.12 关于bytes包的使用
  - 8.13 文件权限
  - 8.14 处理UNIX信号
    - 8.14.1 os.Kill和os.Interrupt的处理
    - 8.14.2 处理所有信号
  - 8.15 Go的UNIX管道编程
    - 8.15.1 精简的cat(1)
  - 8.16 简单的find命令实现
  - 8.17 eBPF的使用
  - 8.18 关于 syscall.PtraceRegs
  - 8.19 追踪系统调用
  - 8.20 用户ID和组ID
  - 8.21 延展阅读
  - 8.22 练习
  - 8.23 本章小结

- 第九章 并发-Goroutines,Channel和Pipeline

  - 9.1 关于进程，线程和goroutines
    - 9.1.1 Go 调度器
    - 9.1.2 并发和并行
  - 9.2 Goroutines
    - 9.2.1 创建一个Goroutine
    - 9.2.2 创建多个Goroutine
  - 9.3 优雅地结束goroutines
    - 9.3.1 当Add()和Done()的数量不匹配时会发生什么？
  - 9.4 Channel(通道)
    - 9.4.1 通道的写入
    - 9.4.2 从通道中读取
    - 9.4.3 通道作为函数参数
  - 9.5 使用多个goroutines形成Pipeline
  - 9.6 延展阅读
  - 9.7 练习
  - 9.8 本章小结

- 第十章 Go 并发-进阶讨论

  - 10.1 重温调度器
    - 10.1.1 环境变量 GOMAXPROCS
  - 10.2 select关键字
  - 10.3 goroutine超时检查的两种方式
    - 10.3.1 方式1
    - 10.3.2 方式2
  - 10.4 重温Channel（通道）
    - 10.4.1 信号通道
    - 10.4.2 可缓冲通道
    - 10.4.3 值为nil的通道
    - 10.4.4 传送channel的通道
    - 10.4.5 指定通道的执行顺序
  - 10.5 通过共享变量来共享内存
    - 10.5.1 sync.Mutex 类型
      - 10.5.1.1 忘记解锁mutex的后果
    - 10.5.2 sync.RWMutex类型
    - 10.5.3 通过goroutine共享内存
  - 10.6 竞争状态
  - 10.7关于 context包
    - 10.7.1 context使用的高级示例
    - 10.7.2 工作池
  - 10.8 延展阅读
  - 10.9 练习
  - 10.10 本章小结

- 第十一章 代码测试，优化以及分析

  - 11.1 本章使用的Go版本

    - 11.1.1 1.10和1.9的版本对比

  - 11.2 安装beta或者RC版本

  - 11.3 关于优化

  - 11.4 优化你的Go代码

  - 11.5 分析Go代码

    - 11.5.1 标准库net/http/pprof
    - 11.5.2 代码分析示例
    - 11.5.3 用于分析的第三方包

    - 11.5.4 Go分析器的web接口
      - 11.5.4.1 使用web接口的分析示例
      - 11.5.4.2 Graphviz快览

  - 11.6 go tool的代码追踪

  - 11.7 测试

    - 11.7.1 编写测试代码

  - 11.8 基准测试

    - 11.8.1 基准测试示例

  - 11.9 基准测试的缓冲写入

  - 11.10 揪出隐藏的代码

  - 11.11 交叉编译

  - 11.12 创建示例函数

  - 11.13 生成文档

  - 11.14 延展阅读

  - 11.15 练习

  - 11.16 本章小结

- 第十二章 Go网络编程基础

  - 12.1 关于net/http,net和http.RoundTripper
    - 12.1.1 http.Response类型
    - 12.1.2 http.Request类型
    - 12.1.3 http.Transport类型
  - 12.2 关于TCP/IP
  - 12.3 关于IPv4和IPv6
  - 12.4 命令行工具netcat
  - 12.5 读取网络接口的配置文件
  - 12.6 实现DNS查询
    - 12.6.1 获取域名的NS记录
    - 12.6.2 获取域名的MX记录
  - 12.7 Go实现web服务器
    - 12.7.1 分析HTTP服务
    - 12.7.2 Go创建web网页
  - 12.8 追踪HTTP
    - 12.8.1 测试HTTP handler
  - 12.9 Go实现web客户端
    - 12.9.1 Go web客户端进阶
  - 12.10 HTTP连接超时
    - 12.10.1 SetDeadline介绍
    - 12.10.2 服务端设置超时时间
    - 12.10.3 设置超时的另外一种方法
  - 12.11 抓包工具Wireshark和tshark
  - 12.12 延展阅读
  - 12.13 练习
  - 12.14 本章小结

- 第十三章 网络编程-构建服务器与客户端

  - 13.1 Go标准库-net
  - 13.2 TCP客户端
    - 13.2.1 另一个版本的TCP客户端
  - 13.3 UDP客户端
  - 13.4 构建UDP服务器
  - 13.5 实现并发TCP服务器
    - 13.5.1 简洁的并发TCP服务器
  - 13.6 远程调用（RPC）
    - 13.6.1 RPC客户端
    - 13.6.2 RPC服务器
  - 13.7 底层网络编程
    - 13.7.1 获取ICMP数据
  - 13.8 接下来的任务
  - 13.9 延展阅读
  - 13.10 练习
  - 13.11 本章小结





