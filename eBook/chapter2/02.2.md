### 垃圾回收

垃圾回收（GC）即释放不再使用的内存空间，换句话说，垃圾回收器会查看有哪些对象超出范围且不能再被引用，并且释放这些对象占用的空间。垃圾回收不是在程序执行前或者执行后进行，而是和Go程序并发执行。Go语言垃圾回收器实现的文档如下：

```GC```与```mutator```线程同时运行，类型准确（也称为精确），且允许多个```GC```线程并行运行。它是使用写屏障实现的并发标记和扫描，它是非代际和非紧凑的。通常情况下，在消除锁定的时候，为了最小化碎片，用大小来隔离每个P分配的空间。

接下来我将会解释更多的术语，首先会展示一种查看垃圾回收进程参数的方法。幸运的是，Go的标准库提供了这种学习和操作的方法，并且提供了更多展示垃圾回收器背后工作原理的方法。相关的代码在```gCall.go```中，接下来分三个部分展示。

```gCall.go```的第一部分代码如下：

>```go
>package main
>import (
>    "fmt"
>    "runtime"
>    "time"
>)
>func printStats(mem runtime.MemStats) {
>    runtime.ReadMemStats(&mem)
>    fmt.Println("mem.Alloc:", mem.Alloc)
>    fmt.Println("mem.TotalAlloc:", mem.TotalAlloc)
>    fmt.Println("mem.HeapAlloc:", mem.HeapAlloc)
>    fmt.Println("mem.NumGC:", mem.NumGC)
>    fmt.Println("-----")
>}
>```

请注意，每当需要检索最近的垃圾回收统计信息时，都必须调用```runtime.ReadMemStats()```函数。```printStats```函数的目的是避免重复的代码。

第二部分的代码如下：

>```go
>func main() {
>    var mem runtime.MemStats
>    printStats(mem)
>    for i := 0; i < 10; i++ {
>        s := make([]byte, 50000000)
>        if s == nil {
>            fmt.Println("Operation failed!")
>        }
>	}
>	printStats(mem)
>```

为了能分配大量的内存空间并且触发垃圾回收器，代码生成了多次且容量很大的切片。

最后一部分的代码，使用Go切片申请了更多的内存空间：

> ```go
>     for i := 0; i < 10; i++ {
>         s := make([]byte, 100000000)
>         if s == nil {
>             fmt.Println("Operation failed!")
>         }
>         time.Sleep(5 * time.Second)
>     }
>     printStats(mem)
> }
> ```

在macOS机器上执行```gColl.go```代码，得到如下输出：

> ```shell
> $ go run gColl.go
> mem.Alloc: 66024
> mem.TotalAlloc: 66024
> mem.HeapAlloc: 66024
> mem.NumGC: 0
> -----
> mem.Alloc: 50078496
> mem.TotalAlloc: 500117056
> mem.HeapAlloc: 50078496
> mem.NumGC: 10
> -----
> mem.Alloc: 76712
> mem.TotalAlloc: 1500199904
> mem.HeapAlloc: 76712
> mem.NumGC: 20
> -----
> ```

虽然你不会一直检查Go垃圾回收器的操作，但是在慢速应用程序上观察Go垃圾回收器运行的方式可以为你节省大量的时间，我可以向你保证，你绝对不会后悔使用这些时间来学习Go垃圾回收器的工作方式。

有一个技巧，可以让您获得Go垃圾回收器操作更详细的输出，这可以通过下一个命令来说明：

> ```$ GODEBUG=gctrace=1 go run gColl.go```

如果，你在```go run```命令前使用```GODEBUG=gctrace=1```，Go会输出垃圾回收器操作时分析的数据。输出的数据格式如下：

> ```shell
> gc 4 @0.025s 0%: 0.002+0.065+0.018 ms clock, 0.021+0.040/0.057/0.003+0.14 ms cpu, 47->47->0 MB, 48 MB goal, 8 P
> gc 17 @30.103s 0%: 0.004+0.080+0.019 ms clock, 0.033+0/0.076/0.071+0.15 ms cpu, 95->95->0 MB, 96 MB goal, 8 P
> ```

前面的输出为您提供了有关垃圾回收过程中堆大小的详细信息。以```47-> 47-> 0 MB```三个一体的值为例。 第一个数字是垃圾回收器运行时的堆大小。 第二个值是垃圾回收器结束时的堆大小。 最后一个值是堆存活的大小。