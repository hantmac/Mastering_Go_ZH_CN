# **元组**

严格来讲，**元组**是由多个部分组成的有序列表，最重要的是Go本身不支持元组类型，虽然Go官方并不关心元组，但实际上它提供了元组的某些操作。

有趣的是我们在第一章已经接触过Go的元组操作，像下面的这种操作，使用一条语句获取两个返回值：

>  min,_ := strconv.ParseFloat(arguments[1], 64)

`tuples.go`中的代码将会分成三部分来解释Go的元组，请注意下面代码中的函数将返回值以元组的形式返回。

第一部分：

> ```go
> package main
> 
> import "fmt"
> 
> func retThree(x int) (int, int, int) {
>       return 2 * x, x*x,-x
> }
> ```

`retThree()`函数返回了包含三个整数元素的元组，这种能力使得函数能够返回一组数据，而无需将它们聚合到结构体重或者返回一个结构体变量。

在第六章你将会学习到如何给函数的返回值命名，这是一个非常方便的特性。

第二部分代码：

> ```go
> func main() {
>    fmt.Println(retThree(10))
>    n1, n2, n3 := retThree(20)
>    fmt.Println(n1,n2,n3)
> ```

这里我们使用了两次`retThree()`函数。第一次我没让你并没有将其返回值保存，第二次使用三个变量保存返回值，在Go的术语中这叫做元组赋值，看到这里，你是不是有了一种`Go支持元组！`的错觉。如果有些返回值你并不关心，可以使用`_`操作符忽略掉它们。要知道，在Go的代码里声明了但是未使用的代码是会导致编译错误的。

第三部分代码：

> ```go
> n1, n2 = n2, n1
>    fmt.Println(n1, n2, n3)
> 
>    x1, x2, x3 := n1*2,n1*n1, -n1
> 
>    fmt.Println(x1,x2,x3)
> }
> ```

可以看到，依靠这种元组操作，我们无需借助`temp`变量就可以实现两个数字的交换。

执行`tuples.go`可得到如下输出：

> $ go run tuples.go
>
> 20 100 -10
>
> 40 400 -20
>
> 400 40 -20
>
> 800 160000 -400